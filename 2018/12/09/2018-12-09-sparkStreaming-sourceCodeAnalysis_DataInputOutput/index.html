<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>sparkStreaming源码解析之数据的产生与导入 | sustcoder</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="spark,源码解析," />
  

  <meta name="description" content="sparkStream的数据的产生与导入思维脑图">
<meta name="keywords" content="spark,streaming,源码,数据生成,数据导出">
<meta property="og:type" content="article">
<meta property="og:title" content="sparkStreaming源码解析之数据的产生与导入">
<meta property="og:url" content="https://sustcoder.github.io/2018/12/09/2018-12-09-sparkStreaming-sourceCodeAnalysis_DataInputOutput/index.html">
<meta property="og:site_name" content="sustcoder">
<meta property="og:description" content="sparkStream的数据的产生与导入思维脑图">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wpsA82A.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wpsC3C6.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps230.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps614F.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps8B7D.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps231.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps232.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps234.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps247.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps248.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps25A.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps25B.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps260.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps261.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps272.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps286.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps297.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps298.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps299.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2A9.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2AA.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2AB.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2BC.tmp.jpg">
<meta property="og:updated_time" content="2019-02-11T08:05:33.519Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sparkStreaming源码解析之数据的产生与导入">
<meta name="twitter:description" content="sparkStream的数据的产生与导入思维脑图">
<meta name="twitter:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wpsA82A.tmp.jpg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cben" rel="stylesheet">


  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f1cc8b0edce213e23b90ab65ff3c30ff";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/blog/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-分发receivers"><span class="toc-text">1. 分发receivers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-选择receivers位置"><span class="toc-text">1.1. 选择receivers位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-首次启动"><span class="toc-text">1.1.1. 首次启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-失败重启"><span class="toc-text">1.1.2. 失败重启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-选择策略"><span class="toc-text">1.1.3. 选择策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-构造Receiver-RDD"><span class="toc-text">1.2. 构造Receiver RDD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-定义启动reciever的Func"><span class="toc-text">1.3. 定义启动reciever的Func</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-分发RDD-Receiver-和Func到具体的excutor"><span class="toc-text">1.4. 分发RDD(Receiver)和Func到具体的excutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-启动Executor"><span class="toc-text">1.4.1. 启动Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-1-启动Receiver"><span class="toc-text">1.4.1.1. 启动Receiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-2-启动blockPushingThread"><span class="toc-text">1.4.1.2. 启动blockPushingThread</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-监控excutor"><span class="toc-text">1.5. 监控excutor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-数据接收"><span class="toc-text">2. 数据接收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-获取kafka参数"><span class="toc-text">2.3.1. 获取kafka参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-链接到kafka"><span class="toc-text">2.3.2. 链接到kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-监听所有topic"><span class="toc-text">2.3.3. 监听所有topic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-异步保存数据"><span class="toc-text">2.3.4. 异步保存数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-数据转存"><span class="toc-text">3. 数据转存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-存储格式"><span class="toc-text">3.1. 存储格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-单条数据"><span class="toc-text">3.1.1. 单条数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-1-控制batch大小"><span class="toc-text">3.1.1.1. 控制batch大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-2-添加数据到arrayBuffer"><span class="toc-text">3.1.1.2. 添加数据到arrayBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-3-定时放入blocakQueue"><span class="toc-text">3.1.1.3. 定时放入blocakQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-4-保存并推送blocks"><span class="toc-text">3.1.1.4. 保存并推送blocks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-4-1-保存"><span class="toc-text">3.1.1.4.1. 保存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-4-2-推送"><span class="toc-text">3.1.1.4.2. 推送</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-bytes格式数据"><span class="toc-text">3.1.2. bytes格式数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-iterator格式数据"><span class="toc-text">3.1.3. iterator格式数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-ByteBuffer格式数据"><span class="toc-text">3.1.4. ByteBuffer格式数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-存储方式"><span class="toc-text">3.2. 存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-BlockManager"><span class="toc-text">3.2.1. BlockManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-WAL"><span class="toc-text">3.2.2. WAL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-数据上报"><span class="toc-text">4. 数据上报</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-wal上报"><span class="toc-text">4.1. wal上报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-BlockManager上报"><span class="toc-text">4.2. BlockManager上报</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-receiver管理"><span class="toc-text">5. receiver管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-分发"><span class="toc-text">5.1. 分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-监控"><span class="toc-text">5.2. 监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-消息类型"><span class="toc-text">5.3. 消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-只接收不回复"><span class="toc-text">5.3.1. 只接收不回复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-1-首次启动消息"><span class="toc-text">5.3.1.1. 首次启动消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-2-重新启动消息"><span class="toc-text">5.3.1.2. 重新启动消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-3-清除blocks消息"><span class="toc-text">5.3.1.3. 清除blocks消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-4-更新接收频率"><span class="toc-text">5.3.1.4. 更新接收频率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-5-错误上报消息"><span class="toc-text">5.3.1.5. 错误上报消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-接收并回复"><span class="toc-text">5.3.2. 接收并回复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-1-注册Receiver消息"><span class="toc-text">5.3.2.1. 注册Receiver消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-2-meta上报消息"><span class="toc-text">5.3.2.2. meta上报消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-3-查询ReceiverIds消息"><span class="toc-text">5.3.2.3. 查询ReceiverIds消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-4-查询ReceiversInfo消息"><span class="toc-text">5.3.2.4. 查询ReceiversInfo消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-5-停止所有Receiver消息"><span class="toc-text">5.3.2.5. 停止所有Receiver消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-6-注销Receiver消息"><span class="toc-text">5.3.2.6. 注销Receiver消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-meta信息管理"><span class="toc-text">5.4. meta信息管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-接收meta信息"><span class="toc-text">5.4.1. 接收meta信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-batch分配"><span class="toc-text">5.4.2. batch分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-计算DAG生成"><span class="toc-text">5.4.3. 计算DAG生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-清除meta信息"><span class="toc-text">5.4.4. 清除meta信息</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-2018-12-09-sparkStreaming-sourceCodeAnalysis_DataInputOutput" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">sparkStreaming源码解析之数据的产生与导入</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.12.09</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>freeli</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="https://sustcoder.github.io//2018/12/09/2018-12-09-sparkStreaming-sourceCodeAnalysis_DataInputOutput/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>此文是从思维导图中导出稍作调整后生成的，思维脑图对代码浏览支持不是很好，为了更好阅读体验，文中涉及到的源码都是删除掉不必要的代码后的伪代码，如需获取更好阅读体验可下载脑图配合阅读：</p>
<p> 此博文共分为四个部分：</p>
<ol>
<li><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wpsA82A.tmp.jpg" alt="img"><a href="https://sustcoder.github.io/2018/12/01/sparkStreaming-sourceCodeAnalysis_DAG/">DAG定义</a></li>
<li><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wpsC3C6.tmp.jpg" alt="img"><a href="https://sustcoder.github.io/2018/12/03/sparkStreaming-sourceCodeAnalysis_job/">Job动态生成</a></li>
<li><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps230.tmp.jpg" alt="img"><a href="https://sustcoder.github.io/2018/12/09/sparkStreaming-sourceCodeAnalysis_DataInputOutput/">数据的产生与导入</a></li>
<li><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps614F.tmp.jpg" alt="img"><a href="https://sustcoder.github.io/2018/12/12/sparkStreaming-sourceCodeAnalysis_faultTolerance/">容错</a></li>
</ol>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps8B7D.tmp.jpg" alt="img"></p>
<p>数据的产生与导入主要分为以下五个部分</p>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps231.tmp.jpg" alt="img"> </p>
<h1 id="1-分发receivers"><a href="#1-分发receivers" class="headerlink" title="1. 分发receivers"></a>1. 分发receivers</h1><p>由 Receiver 的总指挥 ReceiverTracker 分发多个 job（每个 job 有 1 个 task），到多个 executor 上分别启动 ReceiverSupervisor 实例</p>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps232.tmp.jpg" alt="img"> </p>
<p><strong>从ReceiverInputDStreams中获取Receivers，并把他们发送到所有的worker nodes:</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> endpoint:<span class="type">RpcEndpointRef</span>=</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">**launchReceivers**</span></span>()&#123;</span><br><span class="line">		<span class="comment">// DStreamGraph的属性inputStreams</span></span><br><span class="line">		<span class="keyword">val</span> receivers=inputStreams.map&#123;nis=&gt;</span><br><span class="line">			<span class="keyword">val</span> rcvr=nis.getReceiver()</span><br><span class="line">			<span class="comment">// rcvr是对kafka,socket等接受数据的定义</span></span><br><span class="line">			rcvr</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">// 发送到worker</span></span><br><span class="line">		 endpoint.send(<span class="type">StartAllReceivers</span>(receivers))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-选择receivers位置"><a href="#1-1-选择receivers位置" class="headerlink" title="1.1. 选择receivers位置"></a>1.1. <strong>选择receivers位置</strong></h2><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps234.tmp.jpg" alt="img"> </p>
<p><strong>目的地选择分两种情况：初始化选择和失败重启选择</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 分发目的地的计算</span></span><br><span class="line">	<span class="keyword">val</span> schedulingPolicy=</span><br><span class="line">		<span class="keyword">new</span> <span class="type">ReceiverSchedulingPolicy</span>() </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>&#123;</span><br><span class="line">		<span class="comment">// 首次启动</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span>(receivers) =&gt;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 失败重启</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span>(receiver)=&gt;</span><br><span class="line">		...</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-1-首次启动"><a href="#1-1-1-首次启动" class="headerlink" title="1.1.1. 首次启动"></a>1.1.1. <strong>首次启动</strong></h3><p><strong>1. 选择最优executors位置</strong></p>
<p><strong>2. 遍历构造最终分发的excutor</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> schedulingPolicy=</span><br><span class="line">		<span class="keyword">new</span> <span class="type">ReceiverSchedulingPolicy</span>() </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>&#123;</span><br><span class="line">		<span class="comment">// 首次启动</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span>(receivers) =&gt;</span><br><span class="line">			<span class="comment">// 1. 选择最优executors位置</span></span><br><span class="line">			<span class="keyword">val</span> locations=</span><br><span class="line">				schedulingPolicy.scheduleReceivers(</span><br><span class="line">					receivers,getExecutors</span><br><span class="line">				)</span><br><span class="line">			<span class="comment">// 2. 遍历构造最终分发的excutor</span></span><br><span class="line">			<span class="keyword">for</span>(receiver&lt;- receivers)&#123;</span><br><span class="line">				<span class="keyword">val</span> executors = scheduledLocations(</span><br><span class="line">					receiver.streamId)</span><br><span class="line">				startReceiver(receiver, executors)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 失败重启</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span>(receiver)=&gt;</span><br><span class="line">		...</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-失败重启"><a href="#1-1-2-失败重启" class="headerlink" title="1.1.2. 失败重启"></a>1.1.2. <strong>失败重启</strong></h3><p><strong>1.获取之前的executors</strong></p>
<p><strong>2. 计算新的excutor位置</strong></p>
<p>​    <strong>2.1 之前excutors可用，则使用之前的</strong></p>
<p>​    <strong>2.2 之前的不可用则重新计算位置</strong></p>
<p><strong>3. 发送给worker重启receiver</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> schedulingPolicy=</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="type">ReceiverSchedulingPolicy</span>() </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 首次启动</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span>(receivers) =&gt;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 失败重启</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span>(receiver)=&gt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1.获取之前的executors</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> oldScheduledExecutors =getStoredScheduledExecutors(</span><br><span class="line"></span><br><span class="line">				receiver.streamId</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 计算新的excutor位置</span></span><br><span class="line"></span><br><span class="line">		 <span class="keyword">val</span> scheduledLocations = <span class="keyword">if</span> (oldScheduledExecutors.nonEmpty) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1 之前excutors可用，则使用之前的</span></span><br><span class="line"></span><br><span class="line">            oldScheduledExecutors</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.2 之前的不可用则重新计算位置</span></span><br><span class="line"></span><br><span class="line">			schedulingPolicy.rescheduleReceiver(）</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 发送给worker重启receiver</span></span><br><span class="line"></span><br><span class="line">		   startReceiver(</span><br><span class="line"></span><br><span class="line">				receiver, scheduledLocations)</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-选择策略"><a href="#1-1-3-选择策略" class="headerlink" title="1.1.3. 选择策略"></a>1.1.3. <strong>选择策略</strong></h3><p><strong>策略选择由ReceiverSchedulingPolicy实现，默认策略是轮训（round-robin），在1.5版本之前是使用依赖 Spark Core 的 TaskScheduler 进行通用分发，</strong></p>
<p><strong>在1.5之前存在executor分发不均衡问题导致Job执行失败：</strong></p>
<p>如果某个 Task 失败超过 spark.task.maxFailures(默认=4) 次的话，整个 Job 就会失败。这个在长时运行的 Spark Streaming 程序里，Executor 多失效几次就有可能导致 Task 失败达到上限次数了，如果某个 Task 失效一下，Spark Core 的 TaskScheduler 会将其重新部署到另一个 executor 上去重跑。但这里的问题在于，负责重跑的 executor 可能是在下发重跑的那一刻是正在执行 Task 数较少的，但不一定能够将 Receiver 分布的最均衡的。</p>
<p>策略代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scheduledLocations =<span class="type">ReceiverSchedulingPolicy</span>.scheduleReceivers(receivers,xecutors)</span><br><span class="line"><span class="keyword">val</span> scheduledLocations =<span class="type">ReceiverSchedulingPolicy</span>.rescheduleReceiver(receiver, ...)</span><br></pre></td></tr></table></figure>
<h2 id="1-2-构造Receiver-RDD"><a href="#1-2-构造Receiver-RDD" class="headerlink" title="1.2. 构造Receiver RDD"></a>1.2. <strong>构造Receiver RDD</strong></h2><p><strong>将receiver列表转换为RDD</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		startReceiver(receiver, executors)</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>(</span><br><span class="line">			receiver: <span class="type">Receiver</span>[_],</span><br><span class="line"></span><br><span class="line">        	scheduledLocations: <span class="type">Seq</span>[<span class="type">TaskLocation</span>])&#123;	</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>(</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> receiverRDD: <span class="type">RDD</span>[<span class="type">Receiver</span>] =</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scheduledLocations.isEmpty) &#123;</span><br><span class="line"></span><br><span class="line">          	**ssc.sc.makeRDD(<span class="type">Seq</span>(receiver), <span class="number">1</span>)**</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> preferredLocations = scheduledLocations.map(_.toString).distinct</span><br><span class="line"></span><br><span class="line">          ssc.sc.makeRDD(<span class="type">Seq</span>(receiver -&gt; preferredLocations))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      receiverRDD.setName(<span class="string">s" <span class="subst">$receiverId</span>"</span>)				</span><br><span class="line"></span><br><span class="line">	 ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-定义启动reciever的Func"><a href="#1-3-定义启动reciever的Func" class="headerlink" title="1.3. 定义启动reciever的Func"></a>1.3. <strong>定义启动reciever的Func</strong></h2><p><strong>将每个receiver,spark环境变量，hadoop配置文件，检查点路径等信息传送给excutor的接收对象ReceiverSupervisorImpl</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>(</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> startReceiverFunc:</span><br><span class="line"></span><br><span class="line">	<span class="type">Iterator</span>[<span class="type">Receiver</span>[_]]=&gt;<span class="type">Unit</span>=</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	(iterator:<span class="type">Iterator</span>)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> receiver=iterator.next()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> supervisor=</span><br><span class="line"></span><br><span class="line">			<span class="keyword">new</span> <span class="type">ReceiverSupervisoImpl</span>(</span><br><span class="line"></span><br><span class="line">				receiver,</span><br><span class="line"></span><br><span class="line">				<span class="type">SparkEnv</span>,</span><br><span class="line"></span><br><span class="line">				<span class="type">HadoopConf</span>,</span><br><span class="line"></span><br><span class="line">				checkpointDir,</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		supervisor.start(),</span><br><span class="line"></span><br><span class="line">		supervisor.awaitTermination()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-分发RDD-Receiver-和Func到具体的excutor"><a href="#1-4-分发RDD-Receiver-和Func到具体的excutor" class="headerlink" title="1.4. 分发RDD(Receiver)和Func到具体的excutor"></a>1.4. <strong>分发RDD(Receiver)和Func到具体的excutor</strong></h2><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps247.tmp.jpg" alt="img"> </p>
<p><strong>将前两部定义的rdd和fun从driver提交到excutor</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>(</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> future=ssc.sparkContext.submitJob(</span><br><span class="line"></span><br><span class="line">		receiverRDD,</span><br><span class="line"></span><br><span class="line">		startReceverFunc,</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	  ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-启动Executor"><a href="#1-4-1-启动Executor" class="headerlink" title="1.4.1. 启动Executor"></a>1.4.1. <strong>启动Executor</strong></h3><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps248.tmp.jpg" alt="img"> </p>
<p><strong>Executor的启动在Receiver类中定义，在ReceiverSupervisor类中调用，在Receiver的子类中实现</strong></p>
<p>excutor中共需要启动两个线程</p>
<p>​    -1. 启动Receiver接收数据</p>
<p>​    - 2. 启动pushingThread定时推送数据到driver</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisor</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	receiver: <span class="type">Receiver</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	conf: sparkConf</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    onStart()</span><br><span class="line"></span><br><span class="line">    startReceiver()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-1-1-启动Receiver"><a href="#1-4-1-1-启动Receiver" class="headerlink" title="1.4.1.1. 启动Receiver"></a>1.4.1.1. <strong>启动Receiver</strong></h4><p><strong>启动Receiver，开始接收数据</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisor</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	receiver: <span class="type">Receiver</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	conf: sparkConf</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    onStart()</span><br><span class="line"></span><br><span class="line">    startReceiver()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 启动Receiver，开始接收数据</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		receiverState=<span class="type">Started</span></span><br><span class="line"></span><br><span class="line">		receiver.onStart()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-1-2-启动blockPushingThread"><a href="#1-4-1-2-启动blockPushingThread" class="headerlink" title="1.4.1.2. 启动blockPushingThread"></a>1.4.1.2. <strong>启动blockPushingThread</strong></h4><p><strong>启动pushTread，定时推送信息到driver</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisor</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	receiver: <span class="type">Receiver</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	conf: sparkConf</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    onStart()</span><br><span class="line"></span><br><span class="line">    startReceiver()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 启动Receiver，开始接收数据</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		receiverState=<span class="type">Started</span></span><br><span class="line"></span><br><span class="line">		receiver.onStart()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 启动pushTread，定时推送信息到driver</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    registeredBlockGenerators.asScala.foreach &#123; 		_.start() </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// _.start() 的实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockGenerator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">start</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		blockIntervalTimer.start()</span><br><span class="line"></span><br><span class="line">		blockPushingThread.start()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-监控excutor"><a href="#1-5-监控excutor" class="headerlink" title="1.5. 监控excutor"></a>1.5. <strong>监控excutor</strong></h2><p>启动 Receiver 实例，并一直 block 住当前线程</p>
<p>在1.5版本之前，一个job包含多个task，一个task失败次数失败超过4次后，整个Job都会失败，<strong>1.5版本之后一个job只包含一个task,并且添加了可重试机制</strong>，大大增加了job的活性</p>
<p> Spark Core 的 Task 下发时只会参考并大部分时候尊重 Spark Streaming 设置的 preferredLocation 目的地信息，还是有一定可能该分发 Receiver 的 Job 并没有在我们想要调度的 executor 上运行。此时，在第 1 次执行 Task 时，会首先向 ReceiverTracker 发送 RegisterReceiver 消息，只有得到肯定的答复时，才真正启动 Receiver，否则就继续做一个空操作，导致本 Job 的状态是成功执行已完成。当然，ReceiverTracker 也会另外调起一个 Job，来继续尝试 Receiver 分发……如此直到成功为止。</p>
<p>一个 Receiver 的分发 Job 是有可能没有完成分发 Receiver 的目的的，所以 ReceiverTracker 会继续再起一个 Job 来尝试 Receiver 分发。这个机制保证了，如果一次 Receiver 如果没有抵达预先计算好的 executor，就有机会再次进行分发，从而实现在 Spark Streaming 层面对 Receiver 所在位置更好的控制。</p>
<p> 对 Receiver 的监控重启机制</p>
<p>上面分析了每个 Receiver 都有专门的 Job 来保证分发后，我们发现这样一来，Receiver 的失效重启就不受 spark.task.maxFailures(默认=4) 次的限制了。</p>
<p>因为现在的 Receiver 重试不是在 Task 级别，而是在 Job 级别；并且 Receiver 失效后并不会导致前一次 Job 失败，而是前一次 Job 成功、并新起一个 Job 再次进行分发。这样一来，不管 Spark Streaming 运行多长时间，Receiver 总是保持活性的，不会随着 executor 的丢失而导致 Receiver 死去。</p>
<p>// todo 阻塞，知道executor返回发送结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startReceiver</span></span>(</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line"> 		future.onComplete &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Success</span>(_)=&gt;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Failure</span>())=&gt;</span><br><span class="line"></span><br><span class="line">			onReceiverJobFinish(receiverId)</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">		&#125;&#125;(<span class="type">ThreadUtils</span>.sameThread)</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-数据接收"><a href="#2-数据接收" class="headerlink" title="2. 数据接收"></a>2. <strong>数据接收</strong></h1><p>每个 ReceiverSupervisor 启动后将马上生成一个用户提供的 Receiver 实现的实例 —— 该 Receiver 实现可以持续产生或者持续接收系统外数据，比如 TwitterReceiver 可以实时爬取 twitter 数据 —— 并在 Receiver 实例生成后调用 Receiver.onStart()。</p>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps25A.tmp.jpg" alt="img"> </p>
<p> <strong>数据的接收由Executor端的Receiver实现，启动和停止需要子类实现，存储基类实现，供子类调用</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>[<span class="type">T</span>](<span class="params">val storageLevel: <span class="type">StorageLevel</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动和停止需要子类实现</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onStop</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 【存储单条小数据】</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(dataItem: <span class="type">T</span>) &#123;...&#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 【存储数组形式的块数据】</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(dataBuffer: <span class="type">ArrayBuffer</span>[<span class="type">T</span>]) &#123;...&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 【存储 iterator 形式的块数据】</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(dataIterator: <span class="type">Iterator</span>[<span class="type">T</span>]) &#123;...&#125;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 【存储 ByteBuffer 形式的块数据】 </span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(bytes: <span class="type">ByteBuffer</span>) &#123;...&#125;         </span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps25B.tmp.jpg" alt="img"> </p>
<p>通过kafka去接收数据，</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaInputDStream</span> <span class="title">**extends</span> <span class="title">Receiver**</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	_ssc : <span class="type">StreamingContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	kafkaParams : <span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>],</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	topics : <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>],</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	useReliableReceiver : <span class="type">Boolean</span> </span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	storageLevel : <span class="type">StorageLevel</span> </span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>()&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-1-获取kafka参数"><a href="#2-3-1-获取kafka参数" class="headerlink" title="2.3.1. 获取kafka参数"></a>2.3.1. 获取kafka参数</h3><p>拼接kafka consumer所需参数</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaInputDStream</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		 **<span class="comment">// 1. 获取kafka参数**	 </span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">val</span> props=<span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line"></span><br><span class="line">		kafkaParams.foreach(</span><br><span class="line"></span><br><span class="line">			p=&gt;props.put(p._1,p._2)</span><br><span class="line"></span><br><span class="line">		)	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-链接到kafka"><a href="#2-3-2-链接到kafka" class="headerlink" title="2.3.2. 链接到kafka"></a>2.3.2. <strong>链接到kafka</strong></h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaInputDStream</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// kafka链接器</span></span><br><span class="line">	<span class="keyword">var</span> consumerConnector:<span class="type">ConsumerConnector</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 获取kafka参数	 </span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">val</span> props=<span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line"></span><br><span class="line">		kafkaParams.foreach(</span><br><span class="line"></span><br><span class="line">			p=&gt;props.put(p._1,p._2)</span><br><span class="line"></span><br><span class="line">		)	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 链接到kafka</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> consumerConf=</span><br><span class="line"></span><br><span class="line">				<span class="keyword">new</span> <span class="type">ConsumerConfig</span>(props)</span><br><span class="line"></span><br><span class="line">		consumerConnector=</span><br><span class="line"></span><br><span class="line">				<span class="type">Consumer</span>.create(consumerConf)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-监听所有topic"><a href="#2-3-3-监听所有topic" class="headerlink" title="2.3.3. 监听所有topic"></a>2.3.3. 监听所有topic</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaInputDStream</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kafka链接器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> consumerConnector:<span class="type">ConsumerConnector</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 获取kafka参数	 </span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">val</span> props=<span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line"></span><br><span class="line">		kafkaParams.foreach(</span><br><span class="line"></span><br><span class="line">			p=&gt;props.put(p._1,p._2)</span><br><span class="line"></span><br><span class="line">		)	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 链接到kafka</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> consumerConf=</span><br><span class="line"></span><br><span class="line">				<span class="keyword">new</span> <span class="type">ConsumerConfig</span>(props)</span><br><span class="line"></span><br><span class="line">		consumerConnector=</span><br><span class="line"></span><br><span class="line">				<span class="type">Consumer</span>.create(consumerConf)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 监听所有topic</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> topicMessageStreams=</span><br><span class="line"></span><br><span class="line">			consumerConnector.createMessage()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> executorPool=<span class="type">ThreadUtils</span>.</span><br><span class="line"></span><br><span class="line">			newDaemonFixedTreadPool(</span><br><span class="line"></span><br><span class="line">				topics.values.sum,</span><br><span class="line"></span><br><span class="line">				<span class="string">"kafkaMessageHandler"</span></span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		topicMessageStreams.values.foreach(</span><br><span class="line"></span><br><span class="line">			streams=&gt;streams.foreach&#123;</span><br><span class="line"></span><br><span class="line">				stream=&gt;</span><br><span class="line"></span><br><span class="line">					executorPool.submit(</span><br><span class="line"></span><br><span class="line">						<span class="keyword">new</span> <span class="type">MessageHandler</span>(stream)</span><br><span class="line"></span><br><span class="line">					)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-异步保存数据"><a href="#2-3-4-异步保存数据" class="headerlink" title="2.3.4. 异步保存数据"></a>2.3.4. 异步保存数据</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaInputDStream</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kafka链接器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> consumerConnector:<span class="type">ConsumerConnector</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 获取kafka参数	 </span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">val</span> props=<span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line"></span><br><span class="line">		kafkaParams.foreach(</span><br><span class="line"></span><br><span class="line">			p=&gt;props.put(p._1,p._2)</span><br><span class="line"></span><br><span class="line">		)	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 链接到kafka</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> consumerConf=</span><br><span class="line"></span><br><span class="line">				<span class="keyword">new</span> <span class="type">ConsumerConfig</span>(props)</span><br><span class="line"></span><br><span class="line">		consumerConnector=</span><br><span class="line"></span><br><span class="line">				<span class="type">Consumer</span>.create(consumerConf)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 监听所有topic</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> topicMessageStreams=</span><br><span class="line"></span><br><span class="line">			consumerConnector.createMessage()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> executorPool=<span class="type">ThreadUtils</span>.</span><br><span class="line"></span><br><span class="line">			newDaemonFixedTreadPool(</span><br><span class="line"></span><br><span class="line">				topics.values.sum,</span><br><span class="line"></span><br><span class="line">				<span class="string">"kafkaMessageHandler"</span></span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		topicMessageStreams.values.foreach(</span><br><span class="line"></span><br><span class="line">			streams=&gt;streams.foreach&#123;</span><br><span class="line"></span><br><span class="line">				stream=&gt;</span><br><span class="line"></span><br><span class="line">					executorPool.submit(</span><br><span class="line"></span><br><span class="line">						<span class="keyword">new</span> <span class="type">MessageHandler</span>(stream)</span><br><span class="line"></span><br><span class="line">					)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 异步保存数据</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	 stream:<span class="type">KafkaStream</span>[<span class="type">K</span>,<span class="type">V</span>]</span>) <span class="keyword">extends</span> <span class="title">Runable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	 	<span class="function"><span class="keyword">def</span> <span class="title">run</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">val</span> streamIterator=stream.iterator()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(streamIterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">val</span> msgAndMetadata=</span><br><span class="line"></span><br><span class="line">					streamIterator.next()</span><br><span class="line"></span><br><span class="line">				**store(**</span><br><span class="line"></span><br><span class="line">					**msgAndMetadata.key,**</span><br><span class="line"></span><br><span class="line">					**msgAndMetadata.message**</span><br><span class="line"></span><br><span class="line">				**)**</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义的Receiver只需要继承Receiver类，并实现onStart方法里新拉起数据接收线程，并在接收到数据时 store() 到 Spark Streamimg 框架就可以了。</p>
<h1 id="3-数据转存"><a href="#3-数据转存" class="headerlink" title="3. 数据转存"></a>3. <strong>数据转存</strong></h1><p>Receiver 在 onStart() 启动后，就将持续不断地接收外界数据，并持续交给 ReceiverSupervisor 进行数据转储</p>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps260.tmp.jpg" alt="img"> </p>
<h2 id="3-1-存储格式"><a href="#3-1-存储格式" class="headerlink" title="3.1. 存储格式"></a>3.1. <strong>存储格式</strong></h2><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps261.tmp.jpg" alt="img"> </p>
<p><strong>Receiver在调用store方法后，根据不同的入参会调用ReceiverSupervisor的不同方法。ReceiverSupervisor的方法由ReceiverSupervisorImpl实现</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> supervisor:<span class="type">ReceiverSupervisor</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.单条数据</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">strore</span></span>(dataItem: <span class="type">T</span> )&#123;</span><br><span class="line"></span><br><span class="line">		supervisor.pushSigle(dataItem)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. byte数组</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(bytes : <span class="type">ByteBuffer</span>)&#123;</span><br><span class="line"></span><br><span class="line">		supervisor.pushBytes(bytes,<span class="type">None</span>,<span class="type">None</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 迭代器格式</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(dataIterator : <span class="type">Iterator</span>[<span class="type">T</span>])&#123;</span><br><span class="line"></span><br><span class="line">		supervisor.pusthIteratro(dataIterator)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. ByteBuffer格式</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(dataBuffer:<span class="type">ArrayBuffer</span>[<span class="type">T</span>])&#123;</span><br><span class="line"></span><br><span class="line">		supervisor.pushArrayBuffer(dataBuffer)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-单条数据"><a href="#3-1-1-单条数据" class="headerlink" title="3.1.1. 单条数据"></a>3.1.1. <strong>单条数据</strong></h3><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps272.tmp.jpg" alt="img"> </p>
<p><strong>调用ReceiverSupervisorImpl的pushSigle方法保存单条数据</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> defaultBlockGenerator=</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="type">BlockGenerator</span>(</span><br><span class="line"></span><br><span class="line">		blockGeneratorListener, </span><br><span class="line"></span><br><span class="line">		streamId, </span><br><span class="line"></span><br><span class="line">		env.conf</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pushSinge</span></span>(data:<span class="type">Any</span>)&#123;</span><br><span class="line"></span><br><span class="line">		defaultBlockGenerator.addData(data)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-1-控制batch大小"><a href="#3-1-1-1-控制batch大小" class="headerlink" title="3.1.1.1. 控制batch大小"></a>3.1.1.1. <strong>控制batch大小</strong></h4><p><strong>先检查接收数据的频率，控制住频率就控制了每个batch需要处理的最大数据量</strong></p>
<p>就是在加入 currentBuffer 数组时会先由 rateLimiter 检查一下速率，是否加入的频率已经太高。如果太高的话，就需要 block 住，等到下一秒再开始添加。这里的最高频率是由 spark.streaming.receiver.maxRate (default = Long.MaxValue) 控制的，是单个 Receiver 每秒钟允许添加的条数。控制了这个速率，就控制了整个 Spark Streaming 系统每个 batch 需要处理的最大数据量。</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockGenerator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>(data:<span class="type">Any</span>)=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 检查接收频率</span></span><br><span class="line"></span><br><span class="line">		waitToPush()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span>(<span class="params">conf:<span class="type">SparkConf</span></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> maxRateLimit=</span><br><span class="line"></span><br><span class="line">		conf.getLong(</span><br><span class="line"></span><br><span class="line">			<span class="string">"spark.streaming.receiver.maxRate"</span>,</span><br><span class="line"></span><br><span class="line">			<span class="type">Long</span>.<span class="type">MaxValue</span></span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> rateLimiter=<span class="type">GuavaRateLimiter</span>.create(</span><br><span class="line"></span><br><span class="line">		maxRateLimit.toDouble</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">waitToPush</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		rateLimiter.acquire()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-2-添加数据到arrayBuffer"><a href="#3-1-1-2-添加数据到arrayBuffer" class="headerlink" title="3.1.1.2. 添加数据到arrayBuffer"></a>3.1.1.2. <strong>添加数据到arrayBuffer</strong></h4><p><strong>如果频率正常，则把数据添加到数组中，否则抛异常</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockGenerator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> currentBuffer=<span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Any</span>]	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>(data:<span class="type">Any</span>)=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 检查接收频率</span></span><br><span class="line"></span><br><span class="line">		waitToPush()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 添加数据到currentBuffer</span></span><br><span class="line"></span><br><span class="line">		synchronized&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(state==<span class="type">Active</span>)&#123;</span><br><span class="line"></span><br><span class="line">				currentBuffer+=data</span><br><span class="line"></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>&#123;</span><br><span class="line"></span><br><span class="line">					<span class="string">"connot add data ..."</span></span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-3-定时放入blocakQueue"><a href="#3-1-1-3-定时放入blocakQueue" class="headerlink" title="3.1.1.3. 定时放入blocakQueue"></a>3.1.1.3. <strong>定时放入blocakQueue</strong></h4><p>3.1 清空currentBuffer</p>
<p>3.2 将block块放入blocakQueue</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockGenerator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> currentBuffer=<span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Any</span>]	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器：定时更新currentBuffer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> blockIntervalTimer=</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="type">RecurringTimer</span>(</span><br><span class="line"></span><br><span class="line">			clock,</span><br><span class="line"></span><br><span class="line">			blockIntervalMs,</span><br><span class="line"></span><br><span class="line">			updateCurrentBuffer,</span><br><span class="line"></span><br><span class="line">			<span class="string">"BlockGenerator"</span></span><br><span class="line"></span><br><span class="line">		)	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存block的数组大小，默认是10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> queueSize=conf.getInt(</span><br><span class="line"></span><br><span class="line">		<span class="string">"spark.streaming.blockQueueSize"</span>,<span class="number">10</span>)	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> blocksForPushing=</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">Block</span>](queueSize)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>(data:<span class="type">Any</span>)=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 检查接收频率</span></span><br><span class="line"></span><br><span class="line">		waitToPush()</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 添加数据到currentBuffer</span></span><br><span class="line"></span><br><span class="line">		synchronized&#123;</span><br><span class="line"></span><br><span class="line">				currentBuffer+=data</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">updateCurrentBuffer</span></span>(timer:<span class="type">Long</span>)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> newBlock:<span class="type">Block</span>=<span class="literal">null</span></span><br><span class="line"></span><br><span class="line">			synchronized&#123;</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.1 清空currentBuffer</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">val</span> newBlockBuffer=currentBuffer</span><br><span class="line"></span><br><span class="line">				currentBuffer=<span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Any</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 2 将block块放入blocakQueue</span></span><br><span class="line"></span><br><span class="line">				newBlock=</span><br><span class="line"></span><br><span class="line">					<span class="keyword">new</span> <span class="type">Block</span>(id,newBlockBuffer)</span><br><span class="line"></span><br><span class="line">				blocksForPushing.put(newBlock)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-4-保存并推送blocks"><a href="#3-1-1-4-保存并推送blocks" class="headerlink" title="3.1.1.4. 保存并推送blocks"></a>3.1.1.4. <strong>保存并推送blocks</strong></h4><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps286.tmp.jpg" alt="img"> </p>
<p><strong>在初始化BlockGenerator时，启动一个线程去持续的执行pushBlocks方法。如果还没有生成blocks，则阻塞调用queue.poll去获取数据，如果已经存在blocks块，则直接queue.take(10)</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockGenerator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> currentBuffer=<span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Any</span>]	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器：定时更新currentBuffer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> blockIntervalTimer=</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="type">RecurringTimer</span>(</span><br><span class="line"></span><br><span class="line">			clock,</span><br><span class="line"></span><br><span class="line">			blockIntervalMs,</span><br><span class="line"></span><br><span class="line">			updateCurrentBuffer,</span><br><span class="line"></span><br><span class="line">			<span class="string">"BlockGenerator"</span></span><br><span class="line"></span><br><span class="line">		)	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存block的数组大小，默认是10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> queueSize=conf.getInt(</span><br><span class="line"></span><br><span class="line">		<span class="string">"spark.streaming.blockQueueSize"</span>,<span class="number">10</span>)	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> blocksForPushing=</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">Block</span>](queueSize)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 推送block块</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> blockPushingThread=<span class="keyword">new</span> <span class="type">Thread</span>()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">run</span></span>()&#123;keepPushingBlocks()&#125;</span><br><span class="line"></span><br><span class="line">	&#125;		</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>(data:<span class="type">Any</span>)=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 检查接收频率</span></span><br><span class="line"></span><br><span class="line">		waitToPush()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 添加数据到currentBuffer</span></span><br><span class="line"></span><br><span class="line">		synchronized&#123;</span><br><span class="line"></span><br><span class="line">				currentBuffer+=data</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">updateCurrentBuffer</span></span>(timer:<span class="type">Long</span>)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> newBlock:<span class="type">Block</span>=<span class="literal">null</span></span><br><span class="line"></span><br><span class="line">			synchronized&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.1 清空currentBuffer</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">val</span> newBlockBuffer=currentBuffer</span><br><span class="line"></span><br><span class="line">				currentBuffer=<span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Any</span>]</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 2 将block块放入blocakQueue</span></span><br><span class="line">				newBlock=</span><br><span class="line"></span><br><span class="line">					<span class="keyword">new</span> <span class="type">Block</span>(id,newBlockBuffer)</span><br><span class="line"></span><br><span class="line">				blocksForPushing.put(newBlock)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">keepPushingBlocks</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// **4.1 当block正在产时，等待其生成**</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(areBlocksBeingGenerated)&#123;</span><br><span class="line"></span><br><span class="line">				<span class="type">Option</span>(blocksForPushing.poll(</span><br><span class="line"></span><br><span class="line">					waitingTime</span><br><span class="line"></span><br><span class="line">				) <span class="keyword">match</span>&#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">case</span> <span class="type">Some</span>(block)=&gt;</span><br><span class="line"></span><br><span class="line">							pushBLock(block)</span><br><span class="line"></span><br><span class="line">					<span class="keyword">case</span> <span class="type">None</span> =&gt; </span><br><span class="line"></span><br><span class="line">				&#125;)</span><br><span class="line"></span><br><span class="line">			&#125; </span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4.2 block块已经生成</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(!blocksForPushing.isEmpty)&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">val</span> block=blocksForPushing.take()</span><br><span class="line"></span><br><span class="line">				pushBlock(block)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-1-4-1-保存"><a href="#3-1-1-4-1-保存" class="headerlink" title="3.1.1.4.1. 保存"></a>3.1.1.4.1. <strong>保存</strong></h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pushAndReportBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> blockStoreResult =</span><br><span class="line"></span><br><span class="line">		**receivedBlockHandler.storeBlock**(</span><br><span class="line"></span><br><span class="line">			blockId, </span><br><span class="line"></span><br><span class="line">			receivedBlock</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-1-4-2-推送"><a href="#3-1-1-4-2-推送" class="headerlink" title="3.1.1.4.2. 推送"></a>3.1.1.4.2. <strong>推送</strong></h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pushAndReportBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> blockStoreResult =</span><br><span class="line"></span><br><span class="line">		receivedBlockHandler.**storeBlock**(</span><br><span class="line"></span><br><span class="line">			blockId, </span><br><span class="line"></span><br><span class="line">			receivedBlock</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		    <span class="keyword">val</span> blockInfo = <span class="type">ReceivedBlockInfo</span>(</span><br><span class="line"></span><br><span class="line">				streamId, </span><br><span class="line"></span><br><span class="line">				numRecords, </span><br><span class="line"></span><br><span class="line">				metadataOption, </span><br><span class="line"></span><br><span class="line">				blockStoreResult</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    trackerEndpoint.askSync[<span class="type">Boolean</span>](<span class="type">AddBlock</span>(blockInfo))</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-bytes格式数据"><a href="#3-1-2-bytes格式数据" class="headerlink" title="3.1.2. bytes格式数据"></a>3.1.2. <strong>bytes格式数据</strong></h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">ReceiverSupervisorImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pushBytes</span></span>(</span><br><span class="line"></span><br><span class="line">      bytes: <span class="type">ByteBuffer</span>,</span><br><span class="line"></span><br><span class="line">      metadataOption: <span class="type">Option</span>[<span class="type">Any</span>],</span><br><span class="line"></span><br><span class="line">      blockIdOption: <span class="type">Option</span>[<span class="type">StreamBlockId</span>]</span><br><span class="line"></span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">    pushAndReportBlock(</span><br><span class="line"></span><br><span class="line">		<span class="type">ByteBufferBlock</span>(bytes), </span><br><span class="line"></span><br><span class="line">		metadataOption,</span><br><span class="line"></span><br><span class="line">		blockIdOption</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-iterator格式数据"><a href="#3-1-3-iterator格式数据" class="headerlink" title="3.1.3. iterator格式数据"></a>3.1.3. <strong>iterator格式数据</strong></h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">ReceiverSupervisorImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pushIterator</span></span>(</span><br><span class="line"></span><br><span class="line">      iterator: <span class="type">Iterator</span>[_],</span><br><span class="line"></span><br><span class="line">      metadataOption: <span class="type">Option</span>[<span class="type">Any</span>],</span><br><span class="line"></span><br><span class="line">      blockIdOption: <span class="type">Option</span>[<span class="type">StreamBlockId</span>]</span><br><span class="line"></span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">    pushAndReportBlock(<span class="type">IteratorBlock</span>(iterator), metadataOption, blockIdOption)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-ByteBuffer格式数据"><a href="#3-1-4-ByteBuffer格式数据" class="headerlink" title="3.1.4. ByteBuffer格式数据"></a>3.1.4. <strong>ByteBuffer格式数据</strong></h3> <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">ReceiverSupervisorImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pushArrayBuffer</span></span>(</span><br><span class="line"></span><br><span class="line">      arrayBuffer: <span class="type">ArrayBuffer</span>[_],</span><br><span class="line"></span><br><span class="line">      metadataOption: <span class="type">Option</span>[<span class="type">Any</span>],</span><br><span class="line"></span><br><span class="line">      blockIdOption: <span class="type">Option</span>[<span class="type">StreamBlockId</span>]</span><br><span class="line"></span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">    pushAndReportBlock(<span class="type">ArrayBufferBlock</span>(arrayBuffer), metadataOption, blockIdOption)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-存储方式"><a href="#3-2-存储方式" class="headerlink" title="3.2. 存储方式"></a>3.2. <strong>存储方式</strong></h2><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps297.tmp.jpg" alt="img"> </p>
<p>ReceivedBlockHandler 有两个具体的存储策略的实现：</p>
<p>(a) BlockManagerBasedBlockHandler，是直接存到 executor 的内存或硬盘</p>
<p>(b) WriteAheadLogBasedBlockHandler，是先写 WAL，再存储到 executor 的内存或硬盘</p>
<h3 id="3-2-1-BlockManager"><a href="#3-2-1-BlockManager" class="headerlink" title="3.2.1. BlockManager"></a>3.2.1. <strong>BlockManager</strong></h3><p><strong>将数据存储交给blockManager进行管理，调用blockmanager的putIterator方法，由其实现在不同excutor上的复制以及缓存策略。</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockManagerBasedBlockHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	blockManager:<span class="type">BlockManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	storageLevel:<span class="type">StorageLevel</span></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)<span class="keyword">extends</span> <span class="title">ReceivedBlockHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">storeBlock</span></span>(blockId,block)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> numRecords:<span class="type">Option</span>[<span class="type">Long</span>]=<span class="type">None</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> putSucceeded:<span class="type">Boolean</span> = block <span class="keyword">match</span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="type">ArrayBufferBlock</span>(arrayBuffer)=&gt;</span><br><span class="line"></span><br><span class="line">				numRecords=<span class="type">Some</span>(arrayBuffer.size)</span><br><span class="line"></span><br><span class="line">				blockManager.putIterator(</span><br><span class="line"></span><br><span class="line">					blockId,</span><br><span class="line"></span><br><span class="line">					arrayBuffer.iterator,</span><br><span class="line"></span><br><span class="line">					storageLevel,</span><br><span class="line"></span><br><span class="line">					tellMaster=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">				)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="type">IteratorBlock</span>(iterator)=&gt;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">val</span> countIterator=</span><br><span class="line"></span><br><span class="line">					<span class="keyword">new</span> <span class="type">CountingIterator</span>(iterator)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">val</span> putResult=</span><br><span class="line"></span><br><span class="line">					**blockManager.putIterato**r(</span><br><span class="line"></span><br><span class="line">						blockId,</span><br><span class="line"></span><br><span class="line">						arrayBuffer.iterator,</span><br><span class="line"></span><br><span class="line">						storageLevel,</span><br><span class="line"></span><br><span class="line">						tellMaster=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">					)</span><br><span class="line"></span><br><span class="line">				numRecords=countIterator.count</span><br><span class="line"></span><br><span class="line">				putResult</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="type">ByteBufferBlock</span>(byteBuffer)=&gt;</span><br><span class="line"></span><br><span class="line">				blockManager.putBytes(</span><br><span class="line"></span><br><span class="line">					blockId,</span><br><span class="line"></span><br><span class="line">					<span class="keyword">new</span> <span class="type">ChunkedBytedBuffer</span>(</span><br><span class="line"></span><br><span class="line">						byteBuffer.duplicate(),</span><br><span class="line"></span><br><span class="line">						storageLevel,</span><br><span class="line"></span><br><span class="line">						tellMaster=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">					)</span><br><span class="line"></span><br><span class="line">				)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 报告给driver的信息：id和num</span></span><br><span class="line"></span><br><span class="line">			<span class="type">BlockManagerBasedStoreResult</span>(</span><br><span class="line"></span><br><span class="line">				blockId,</span><br><span class="line"></span><br><span class="line">				numRecords</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChunkedBytedBuffer: 将byte数组分片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// byteBuffer.duplicate(): 复制</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-WAL"><a href="#3-2-2-WAL" class="headerlink" title="3.2.2. WAL"></a>3.2.2. <strong>WAL</strong></h3><p>WriteAheadLogBasedBlockHandler 的实现则是同时写到可靠存储的 WAL 中和 executor 的 BlockManager 中；在<strong>两者都写完成后，再上报块数据的 meta 信息</strong>。</p>
<p><strong>BlockManager 中的块数据是计算时首选使用的，只有在 executor 失效时，才去 WAL 中读取写入过的数据</strong>。</p>
<p>同其它系统的 WAL 一样，数据是完全顺序地写入 WAL 的；在稍后上报块数据的 meta 信息，就额外包含了块数据所在的 WAL 的路径，及在 WAL 文件内的偏移地址和长度。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteAheadLogBasedBlockHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">	blockManager: <span class="type">BlockManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    serializerManager: <span class="type">SerializerManager</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    streamId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    storageLevel: <span class="type">StorageLevel</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    hadoopConf: <span class="type">Configuration</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    checkpointDir: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    clock: <span class="type">Clock</span> = new <span class="type">SystemClock</span></span></span></span><br><span class="line"><span class="class"><span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)<span class="keyword">extends</span> <span class="title">ReceivedBlockHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存超时时间</span></span><br><span class="line"></span><br><span class="line">	blockStoreTimeout = conf.getInt(    		</span><br><span class="line">    </span><br><span class="line">    		<span class="string">"spark.streaming.receiver.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			blockStoreTimeout"</span>,<span class="number">30</span>).seconds</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写log类</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> writeAheadLog=<span class="type">WriteAheadLogUtils</span>.</span><br><span class="line"></span><br><span class="line">		creatLogForReceiver(</span><br><span class="line"></span><br><span class="line">			conf,</span><br><span class="line"></span><br><span class="line">			checkpointDirToLogDir(</span><br><span class="line"></span><br><span class="line">					checkpointDir,</span><br><span class="line"></span><br><span class="line">					streamId,</span><br><span class="line"></span><br><span class="line">					hadoopConf</span><br><span class="line"></span><br><span class="line">				)</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">storeBlock</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 执行blockManager</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> serializedBlock = block <span class="keyword">match</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 执行保存到log</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用future异步执行</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> storeInBlockManagerFuture=<span class="type">Future</span>&#123;</span><br><span class="line"></span><br><span class="line">			blockManger.putBytes(...serializedBlock)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> storeInWriteAheadLogFuture=<span class="type">Future</span>&#123;</span><br><span class="line"></span><br><span class="line">			writeAheadLog.write(...serializedBlock)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> combineFuture=</span><br><span class="line"></span><br><span class="line">			storeInBlockManagerFuture.zip(</span><br><span class="line"></span><br><span class="line">				storeInWriteAHeadLogFuture	</span><br><span class="line"></span><br><span class="line">			).map(_._2)</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> walRecordHandle=<span class="type">ThreadUtils</span>.</span><br><span class="line"></span><br><span class="line">			awaitUtils.awaitResult(</span><br><span class="line"></span><br><span class="line">				combineFuture,blockStoreTimeout</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		<span class="type">WriteAheandLogBasedStoreResult</span>(</span><br><span class="line"></span><br><span class="line">			blockId,</span><br><span class="line"></span><br><span class="line">			numRecords,</span><br><span class="line"></span><br><span class="line">			walRecordHandle</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// future1.zip(future2): 合并future,返回tuple(future)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个future中有一个失败，则失败</span></span><br></pre></td></tr></table></figure>
<h1 id="4-数据上报"><a href="#4-数据上报" class="headerlink" title="4. 数据上报"></a>4. <strong>数据上报</strong></h1><p>每次成块在 executor 存储完毕后，ReceiverSupervisor 就会及时上报块数据的 meta 信息给 driver 端的 ReceiverTracker；这里的 meta 信息包括数据的标识 id，数据的位置，数据的条数，数据的大小等信息</p>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps298.tmp.jpg" alt="img"> </p>
<p><strong>ReceiverSupervisor会将数据的标识ID，数据的位置，数据的条数，数据的大小等信息上报给driver</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverSupervisorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pushAndReportBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> blockStoreResult =</span><br><span class="line"></span><br><span class="line">		receivedBlockHandler.storeBlock(</span><br><span class="line"></span><br><span class="line">			blockId, </span><br><span class="line"></span><br><span class="line">			receivedBlock</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    <span class="keyword">val</span> blockInfo = <span class="type">ReceivedBlockInfo</span>(</span><br><span class="line"></span><br><span class="line">				**streamId,** </span><br><span class="line"></span><br><span class="line">				**numRecords,** </span><br><span class="line"></span><br><span class="line">				**metadataOption,** </span><br><span class="line"></span><br><span class="line">				**blockStoreResult**</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    trackerEndpoint.askSync[<span class="type">Boolean</span>](<span class="type">AddBlock</span>(blockInfo))</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-wal上报"><a href="#4-1-wal上报" class="headerlink" title="4.1. wal上报"></a>4.1. <strong>wal上报</strong></h2><p>// 报告给driver的信息：blockId，block数量，<strong>walRecordHandle</strong>        </p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">WriteAheandLogBasedStoreResult</span>(</span><br><span class="line"></span><br><span class="line">	blockId,</span><br><span class="line"></span><br><span class="line">	numRecords,</span><br><span class="line"></span><br><span class="line">	**walRecordHandle**</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="4-2-BlockManager上报"><a href="#4-2-BlockManager上报" class="headerlink" title="4.2. BlockManager上报"></a>4.2. <strong>BlockManager上报</strong></h2><p>// <strong>报告给driver的信息：id和num</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockManagerBasedStoreResult</span>(</span><br><span class="line"></span><br><span class="line">	blockId, </span><br><span class="line"></span><br><span class="line">	numRecords</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="5-receiver管理"><a href="#5-receiver管理" class="headerlink" title="5. receiver管理"></a>5. <strong>receiver管理</strong></h1><ol>
<li>分发和监控receiver</li>
<li>作为RpcEndpoint和reciever通信，接收和发送消息</li>
<li>管理上报的meta信息</li>
</ol>
<p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps299.tmp.jpg" alt="img"> </p>
<p>一方面 Receiver 将通过 AddBlock 消息上报 meta 信息给 ReceiverTracker，另一方面 JobGenerator 将在每个 batch 开始时要求 ReceiverTracker 将已上报的块信息进行 batch 划分，ReceiverTracker 完成了块数据的 meta 信息管理工作。</p>
<p>具体的，ReceiverTracker 有一个成员 ReceivedBlockTracker，专门负责已上报的块数据 meta 信息管理。</p>
<h2 id="5-1-分发"><a href="#5-1-分发" class="headerlink" title="5.1. 分发"></a>5.1. <strong>分发</strong></h2><p>在 ssc.start() 时，将隐含地调用 ReceiverTracker.start()；而 ReceiverTracker.start() 最重要的任务就是调用自己的 launchReceivers() 方法将 Receiver 分发到多个 executor 上去。然后在每个 executor 上，由 <strong>ReceiverSupervisor</strong> 来分别启动一个 Receiver 接收数据</p>
<p>而且在 1.5.0 版本以来引入了 <strong>ReceiverSchedulingPolicy</strong>，是在 Spark Streaming 层面添加对 Receiver 的分发目的地的计算，相对于之前版本依赖 Spark Core 的 TaskScheduler 进行通用分发，新的 ReceiverSchedulingPolicy 会对 Streaming 应用的更好的语义理解，也能计算出更好的分发策略。</p>
<p>并且还通过每个 <strong>Receiver</strong> 对应 1 个 Job 的方式，保证了 Receiver 的多次分发，和失效后的重启、永活</p>
<h2 id="5-2-监控"><a href="#5-2-监控" class="headerlink" title="5.2. 监控"></a>5.2. <strong>监控</strong></h2><h2 id="5-3-消息类型"><a href="#5-3-消息类型" class="headerlink" title="5.3. 消息类型"></a>5.3. <strong>消息类型</strong></h2><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2A9.tmp.jpg" alt="img"> </p>
<p><strong>ReceiverTracker</strong>：</p>
<p>RpcEndPoint 可以理解为 RPC 的 server 端,底层由netty提供通信支持，供 client 调用。</p>
<p>ReceiverTracker 作为 RpcEndPoint 的地址 —— 即 driver 的地址 —— 是公开的，可供 Receiver 连接；如果某个 Receiver 连接成功，那么 ReceiverTracker 也就持有了这个 Receiver 的 RpcEndPoint。这样一来，通过发送消息，就可以实现双向通信。</p>
<h3 id="5-3-1-只接收不回复"><a href="#5-3-1-只接收不回复" class="headerlink" title="5.3.1. 只接收不回复"></a>5.3.1. <strong>只接收不回复</strong></h3><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2AA.tmp.jpg" alt="img"> </p>
<p>只接收消息不回复，除了错误上报消息是excutor发送的以外，其余都是driver的tracker自己给自己发送的命令,接收消息均在ReceiverTracker.receive方法中实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>:<span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Unit</span>]=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">CleanupOldBlocks</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">ReportError</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-1-1-首次启动消息"><a href="#5-3-1-1-首次启动消息" class="headerlink" title="5.3.1.1. 首次启动消息"></a>5.3.1.1. <strong>首次启动消息</strong></h4><p>在 ReceiverTracker 刚启动时，发给自己这个消息，触发具体的 schedulingPolicy 计算，和后续分发</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>:<span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Unit</span>]=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span> =&gt; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> scheduledLocations = schedulingPolicy.</span><br><span class="line"></span><br><span class="line">				scheduleReceivers(</span><br><span class="line"></span><br><span class="line">				receivers, </span><br><span class="line"></span><br><span class="line">				getExecutors</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (receiver &lt;- receivers) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> executors = scheduledLocations(</span><br><span class="line"></span><br><span class="line">				receiver.</span><br><span class="line"></span><br><span class="line">				streamId</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">          updateReceiverScheduledExecutors(</span><br><span class="line"></span><br><span class="line">				receiver.</span><br><span class="line"></span><br><span class="line">				streamId, </span><br><span class="line"></span><br><span class="line">				executors</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">          receiverPreferredLocations(</span><br><span class="line"></span><br><span class="line">				receiver.streamId) = </span><br><span class="line"></span><br><span class="line">			receiver.preferredLocation</span><br><span class="line"></span><br><span class="line">          	startReceiver(receiver, executors)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">CleanupOldBlocks</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">ReportError</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-1-2-重新启动消息"><a href="#5-3-1-2-重新启动消息" class="headerlink" title="5.3.1.2. 重新启动消息"></a>5.3.1.2. <strong>重新启动消息</strong></h4><p>当初始分发的 executor 不对，或者 Receiver 失效等情况出现，发给自己这个消息，触发 Receiver 重新分发</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>:<span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Unit</span>]=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 失败重启</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span>(receiver)=&gt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1.获取之前的executors</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> oldScheduledExecutors = 			getStoredScheduledExecutors(</span><br><span class="line"></span><br><span class="line">				receiver.streamId</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 计算新的excutor位置</span></span><br><span class="line"></span><br><span class="line">		 <span class="keyword">val</span> scheduledLocations = <span class="keyword">if</span> 			(oldScheduledExecutors.nonEmpty) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1 之前excutors可用，则使用之前的</span></span><br><span class="line"></span><br><span class="line">            oldScheduledExecutors</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.2 之前的不可用则重新计算位置</span></span><br><span class="line"></span><br><span class="line">			schedulingPolicy.rescheduleReceiver(）</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 发送给worker重启receiver</span></span><br><span class="line"></span><br><span class="line">		   startReceiver(</span><br><span class="line"></span><br><span class="line">				receiver, scheduledLocations)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">CleanupOldBlocks</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">ReportError</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-1-3-清除blocks消息"><a href="#5-3-1-3-清除blocks消息" class="headerlink" title="5.3.1.3. 清除blocks消息"></a>5.3.1.3. <strong>清除blocks消息</strong></h4><p>当块数据已完成计算不再需要时，发给自己这个消息，将给所有的 Receiver 转发此 CleanupOldBlocks 消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>:<span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Unit</span>]=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span> =&gt; ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">CleanupOldBlocks</span> =&gt; </span><br><span class="line"></span><br><span class="line">			receiverTrackingInfos.values.flatMap(</span><br><span class="line"></span><br><span class="line">				_.endpoint</span><br><span class="line"></span><br><span class="line">			).foreach(</span><br><span class="line"></span><br><span class="line">				_.send(c)</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">ReportError</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-1-4-更新接收频率"><a href="#5-3-1-4-更新接收频率" class="headerlink" title="5.3.1.4. 更新接收频率"></a>5.3.1.4. <strong>更新接收频率</strong></h4><p>ReceiverTracker 动态计算出某个 Receiver 新的 rate limit，将给具体的 Receiver 发送 UpdateRateLimit 消息</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>:<span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Unit</span>]=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">CleanupOldBlocks</span> =&gt; ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		 <span class="keyword">for</span> (info &lt;- 			receiverTrackingInfos.get(streamUID);</span><br><span class="line"></span><br><span class="line"> 			eP &lt;- info.endpoint) &#123;</span><br><span class="line"></span><br><span class="line">          		eP.send(<span class="type">UpdateRateLimit</span>(newRate))</span><br><span class="line"></span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">ReportError</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-1-5-错误上报消息"><a href="#5-3-1-5-错误上报消息" class="headerlink" title="5.3.1.5. 错误上报消息"></a>5.3.1.5. <strong>错误上报消息</strong></h4> <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>:<span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Unit</span>]=&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StartAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RestartReceiver</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">CleanupOldBlocks</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span> =&gt; ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">ReportError</span> =&gt; </span><br><span class="line"></span><br><span class="line">		reportError(streamId, message, error)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-接收并回复"><a href="#5-3-2-接收并回复" class="headerlink" title="5.3.2. 接收并回复"></a>5.3.2. <strong>接收并回复</strong></h3><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2AB.tmp.jpg" alt="img"> </p>
<p>接收executor的消息，处理完毕后并回复给executor</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AddBlock</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">DeregisterReceiver</span>() =&gt; ... </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AllReceiverIds</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StopAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-1-注册Receiver消息"><a href="#5-3-2-1-注册Receiver消息" class="headerlink" title="5.3.2.1. 注册Receiver消息"></a>5.3.2.1. <strong>注册Receiver消息</strong></h4><p>由 Receiver 在试图启动的过程中发来，将回复允许启动，或不允许启动</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> successful=registerReceiver(</span><br><span class="line"></span><br><span class="line">			streamId,</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">type</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			<span class="title">host</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			<span class="title">executorId</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			<span class="title">receiverEndpoint</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			<span class="title">context</span>.<span class="title">senderAddress</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		<span class="title">context</span>.<span class="title">reply</span>(<span class="params">successful</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		</span></span><br><span class="line"><span class="class">		<span class="title">case</span> <span class="title">AddBlock</span>(<span class="params"></span>) <span class="title">=&gt;</span> ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		<span class="title">case</span> <span class="title">DeregisterReceiver</span>(<span class="params"></span>) <span class="title">=&gt;</span> ... </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		<span class="title">case</span> <span class="title">AllReceiverIds</span> <span class="title">=&gt;</span> ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		<span class="title">case</span> <span class="title">GetAllReceiverInfo</span> <span class="title">=&gt;</span> ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		<span class="title">case</span> <span class="title">StopAllReceivers</span> <span class="title">=&gt;</span> ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-2-meta上报消息"><a href="#5-3-2-2-meta上报消息" class="headerlink" title="5.3.2.2. meta上报消息"></a>5.3.2.2. <strong>meta上报消息</strong></h4><p>具体的块数据 meta 上报消息，由 Receiver 发来，将返回成功或失败</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AddBlock</span>() =&gt;</span><br><span class="line"></span><br><span class="line">			context.reply(</span><br><span class="line"></span><br><span class="line">				addBlock(receivedBlockInfo)</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">DeregisterReceiver</span>() =&gt; ... </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AllReceiverIds</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">GetAllReceiverInfo</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StopAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-3-查询ReceiverIds消息"><a href="#5-3-2-3-查询ReceiverIds消息" class="headerlink" title="5.3.2.3. 查询ReceiverIds消息"></a>5.3.2.3. <strong>查询ReceiverIds消息</strong></h4><p>executor发送的本地消息。在 ReceiverTracker stop() 的过程中，查询是否还有活跃的 Receiver，返回所有或者的receiverId</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AddBlock</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">DeregisterReceiver</span>() =&gt; ... </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AllReceiverIds</span> =&gt; </span><br><span class="line"></span><br><span class="line">			context.reply(</span><br><span class="line"></span><br><span class="line">				receiverTrackingInfos.filter(</span><br><span class="line"></span><br><span class="line">					_._2.state != 					<span class="type">ReceiverState</span>.<span class="type">INACTIVE</span></span><br><span class="line"></span><br><span class="line">				).keys.toSeq</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">GetAllReceiverInfo</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StopAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-4-查询ReceiversInfo消息"><a href="#5-3-2-4-查询ReceiversInfo消息" class="headerlink" title="5.3.2.4. 查询ReceiversInfo消息"></a>5.3.2.4. <strong>查询ReceiversInfo消息</strong></h4><p>查询所有excutors的信息给receiver</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AddBlock</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">DeregisterReceiver</span>() =&gt;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AllReceiverIds</span> =&gt; ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">GetAllReceiverInfo</span> =&gt; </span><br><span class="line"></span><br><span class="line">			context.reply(</span><br><span class="line"></span><br><span class="line">				receiverTrackingInfos.toMap</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StopAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-5-停止所有Receiver消息"><a href="#5-3-2-5-停止所有Receiver消息" class="headerlink" title="5.3.2.5. 停止所有Receiver消息"></a>5.3.2.5. <strong>停止所有Receiver消息</strong></h4><p>在 ReceiverTracker stop() 的过程刚开始时，要求 stop 所有的 Receiver；将向所有的 Receiver 发送 stop 信息,并返回true</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AddBlock</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">DeregisterReceiver</span>() =&gt; ... </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AllReceiverIds</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">GetAllReceiverInfo</span> =&gt; ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StopAllReceivers</span> =&gt; </span><br><span class="line"></span><br><span class="line">			 assert(isTrackerStopping || 					isTrackerStopped)</span><br><span class="line"></span><br><span class="line">        			receiverTrackingInfos.values.flatMap(</span><br><span class="line"></span><br><span class="line">				_.endpoint</span><br><span class="line"></span><br><span class="line">			).foreach &#123;</span><br><span class="line"></span><br><span class="line">				 _.send(<span class="type">StopReceiver</span>)</span><br><span class="line"></span><br><span class="line">			 &#125;</span><br><span class="line"></span><br><span class="line">        	context.reply(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-6-注销Receiver消息"><a href="#5-3-2-6-注销Receiver消息" class="headerlink" title="5.3.2.6. 注销Receiver消息"></a>5.3.2.6. <strong>注销Receiver消息</strong></h4><p>由 Receiver 发来，停止receiver，处理后，无论如何都返回 true</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context:<span class="type">RpcCallContext</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">RegisterReceiver</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AddBlock</span>() =&gt; ...</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">DeregisterReceiver</span>() =&gt;</span><br><span class="line"></span><br><span class="line">			deregisterReceiver(</span><br><span class="line"></span><br><span class="line">				streamId, </span><br><span class="line"></span><br><span class="line">				message, </span><br><span class="line"></span><br><span class="line">				error</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">       		 context.reply(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">AllReceiverIds</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">GetAllReceiverInfo</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="type">StopAllReceivers</span> =&gt; ...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-meta信息管理"><a href="#5-4-meta信息管理" class="headerlink" title="5.4. meta信息管理"></a>5.4. <strong>meta信息管理</strong></h2><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/wps2BC.tmp.jpg" alt="img"> </p>
<h3 id="5-4-1-接收meta信息"><a href="#5-4-1-接收meta信息" class="headerlink" title="5.4.1. 接收meta信息"></a>5.4.1. <strong>接收meta信息</strong></h3><p>addBlock(receivedBlockInfo: ReceivedBlockInfo)方法接收到某个 Receiver 上报上来的块数据 meta 信息，将其加入到 streamIdToUnallocatedBlockQueues 里</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceivedBlockTracker</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上报上来的、但尚未分配入 batch 的 Block 块数据的 meta</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> streamIdToUnallocatedBlockQueues = </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">ReceivedBlockQueue</span>]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// WAL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> writeResult=</span><br><span class="line"></span><br><span class="line">		writeToLog(</span><br><span class="line"></span><br><span class="line">			<span class="type">BlockAdditionEvent</span>(</span><br><span class="line"></span><br><span class="line">				receivedBlockInfo</span><br><span class="line"></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(writeResult)&#123;</span><br><span class="line"></span><br><span class="line">		synchronized&#123;</span><br><span class="line"></span><br><span class="line">			streamIdToUnallocatedBlockQueues.</span><br><span class="line"></span><br><span class="line">				getOrElseUpdate(</span><br><span class="line"></span><br><span class="line">					streamId, </span><br><span class="line"></span><br><span class="line">					<span class="keyword">new</span> <span class="type">ReceivedBlockQueue</span>()</span><br><span class="line"></span><br><span class="line">				)+=</span><br><span class="line"></span><br><span class="line">			receivedBlockInfo</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-batch分配"><a href="#5-4-2-batch分配" class="headerlink" title="5.4.2. batch分配"></a>5.4.2. <strong>batch分配</strong></h3><p>JobGenerator 在发起新 batch 的计算时，将 streamIdToUnallocatedBlockQueues 的内容，以传入的 batchTime 参数为 key，<strong>添加到 timeToAllocatedBlocks 里，并更新 lastAllocatedBatchTime</strong></p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceivedBlockTracker</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上报上来的、已分配入 batch 的 Block 块数据的 meta,按照 batch 进行一级索引、再按照 receiverId 进行二级索引的 queue，所以是一个 HashMap: time → HashMap</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> timeToAllocatedBlocks = </span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Time</span>,</span><br><span class="line"></span><br><span class="line">			<span class="type">AllocatedBlocks</span>:<span class="type">Map</span>[</span><br><span class="line"></span><br><span class="line">					<span class="type">Int</span>, </span><br><span class="line"></span><br><span class="line">					<span class="type">Seq</span>[<span class="type">ReceivedBlockInfo</span>]</span><br><span class="line"></span><br><span class="line">			]</span><br><span class="line"></span><br><span class="line">		]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录了最近一个分配完成的 batch 是哪个</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> lastAllocatedBatchTime: <span class="type">Time</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集所有未分配的blocks</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocateBlocksToBatch</span></span>(batchTime: <span class="type">Time</span>): 	<span class="type">Unit</span> = synchronized &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时间是否合法：大于最近收集的时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastAllocatedBatchTime == <span class="literal">null</span> || batchTime &gt; lastAllocatedBatchTime) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 从未分配队列中取出blocks</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> streamIdToBlocks = streamIds.map &#123; 			</span><br><span class="line">    		streamId =&gt;(streamId,getReceivedBlockQueue(streamId)					</span><br><span class="line">				.dequeueAll(x =&gt; <span class="literal">true</span>))</span><br><span class="line">      		&#125;.toMap</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> allocatedBlocks =<span class="type">AllocatedBlocks</span>(streamIdToBlocks)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (writeToLog(<span class="type">BatchAllocationEvent</span>(batchTime, allocatedBlocks))) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 放入已分配队列</span></span><br><span class="line"></span><br><span class="line">        timeToAllocatedBlocks.put(</span><br><span class="line"></span><br><span class="line">			batchTime, allocatedBlocks)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新最近分配的时间戳</span></span><br><span class="line"></span><br><span class="line">        lastAllocatedBatchTime = batchTime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     logInfo(<span class="string">s"Possibly processed batch <span class="subst">$batchTime</span> needs to be processed again in WAL recovery"</span>)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-3-计算DAG生成"><a href="#5-4-3-计算DAG生成" class="headerlink" title="5.4.3. 计算DAG生成"></a>5.4.3. <strong>计算DAG生成</strong></h3><p>JobGenerator 在发起新 batch 的计算时，由 DStreamGraph 生成 RDD DAG 实例时，调用getBlocksOfBatch(batchTime: Time)查 timeToAllocatedBlocks，获得划入本 batch 的块数据元信息，由此生成处理对应块数据的 RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceivedBlockTracker</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getBlocksOfBatch</span></span>(batchTime: <span class="type">Time</span>): 	<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">ReceivedBlockInfo</span>]] = 	synchronized &#123;</span><br><span class="line"></span><br><span class="line">    timeToAllocatedBlocks.get(batchTime).map &#123; 		_.streamIdToAllocatedBlocks 	&#125;.getOrElse(<span class="type">Map</span>.empty)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-4-清除meta信息"><a href="#5-4-4-清除meta信息" class="headerlink" title="5.4.4. 清除meta信息"></a>5.4.4. <strong>清除meta信息</strong></h3><p>当一个 batch 已经计算完成、可以把已追踪的块数据的 meta 信息清理掉时调用，将通过job清理 timeToAllocatedBlocks 表里对应 cleanupThreshTime 之前的所有 batch 块数据 meta 信息</p>
 <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceivedBlockTracker</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanupOldBatches</span></span>(cleanupThreshTime: <span class="type">Time</span>, waitForCompletion: <span class="type">Boolean</span>): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> timesToCleanup = 	timeToAllocatedBlocks.keys.</span><br><span class="line"></span><br><span class="line">		filter &#123; _ &lt; cleanupThreshTime &#125;.toSeq&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writeToLog(</span><br><span class="line"></span><br><span class="line"><span class="type">BatchCleanupEvent</span>(timesToCleanup))) &#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 清除已分配batch队列 </span></span><br><span class="line"></span><br><span class="line">	timeToAllocatedBlocks --= timesToCleanup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清除WAL</span></span><br><span class="line"></span><br><span class="line">	writeAheadLogOption.foreach(</span><br><span class="line"></span><br><span class="line">		_.clean(</span><br><span class="line"></span><br><span class="line">		cleanupThreshTime.milliseconds, 		waitForCompletion)</span><br><span class="line"></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 脑图制作参考：<a href="https://github.com/lw-lin/CoolplaySpark" target="_blank" rel="noopener">https://github.com/lw-lin/CoolplaySpark</a></p>
<p>完整脑图链接地址：<a href="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/spark-streaming-all.png" target="_blank" rel="noopener">https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/srccode/spark-streaming-all.png</a></p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持sustcoder</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/12/03/2018-12-03-sparkStreaming-sourceCodeAnalysis_job/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/12/12/2018-12-12-sparkStreaming-sourceCodeAnalysis_faultTolerance/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>





   
      <div class="git"></div>
   
</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/blog/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'https://sustcoder.github.io/2018/12/09/2018-12-09-sparkStreaming-sourceCodeAnalysis_DataInputOutput/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
