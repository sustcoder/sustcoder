<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>sparkCore源码解析之block | sustcoder</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="spark,源码解析," />
  

  <meta name="description" content="1. 标记Apache Spark中，对Block的查询、存储管理，是通过唯一的Block ID来进行区分的。 同一个Spark Application，以及多个运行的Application之间，对应的Block都具有唯一的ID 1.1. 种类需要在worker和driver间共享数据时，就需要对这个数据进行唯一的标识，常用的需要传输的block信息有以下几类RDDBlockId、Shuffle">
<meta name="keywords" content="spark,core,源码,block">
<meta property="og:type" content="article">
<meta property="og:title" content="sparkCore源码解析之block">
<meta property="og:url" content="https://sustcoder.github.io/2019/01/14/2018-12-01-sparkCore-sorceCodeAnalysis-block/index.html">
<meta property="og:site_name" content="sustcoder">
<meta property="og:description" content="1. 标记Apache Spark中，对Block的查询、存储管理，是通过唯一的Block ID来进行区分的。 同一个Spark Application，以及多个运行的Application之间，对应的Block都具有唯一的ID 1.1. 种类需要在worker和driver间共享数据时，就需要对这个数据进行唯一的标识，常用的需要传输的block信息有以下几类RDDBlockId、Shuffle">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/Block.png">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E0A.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E0C.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E0D.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E1E.tmp.jpg">
<meta property="og:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E2E.tmp.jpg">
<meta property="og:updated_time" content="2019-01-14T11:11:28.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sparkCore源码解析之block">
<meta name="twitter:description" content="1. 标记Apache Spark中，对Block的查询、存储管理，是通过唯一的Block ID来进行区分的。 同一个Spark Application，以及多个运行的Application之间，对应的Block都具有唯一的ID 1.1. 种类需要在worker和driver间共享数据时，就需要对这个数据进行唯一的标识，常用的需要传输的block信息有以下几类RDDBlockId、Shuffle">
<meta name="twitter:image" content="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/Block.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cben" rel="stylesheet">


  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f1cc8b0edce213e23b90ab65ff3c30ff";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/blog/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-标记"><span class="toc-text">1. 标记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-种类"><span class="toc-text">1.1. 种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-生成规则"><span class="toc-text">1.2. 生成规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-存储"><span class="toc-text">2. 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-MemoryStore"><span class="toc-text">2.1. MemoryStore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-DiskStore"><span class="toc-text">2.2. DiskStore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-DiskBlockManager"><span class="toc-text">2.2.1. DiskBlockManager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-offHeap"><span class="toc-text">2.3. offHeap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-内存管理模型"><span class="toc-text">3. 内存管理模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-StaticMemoryManager"><span class="toc-text">3.1. StaticMemoryManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-UnifiedMemoryManager"><span class="toc-text">3.2. UnifiedMemoryManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-内存划分"><span class="toc-text">3.2.1. 内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-1-Storage内存区"><span class="toc-text">3.2.1.1. Storage内存区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-2-Execution内存区"><span class="toc-text">3.2.1.2. Execution内存区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-3-预留内存"><span class="toc-text">3.2.1.3. 预留内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-4-非堆内存"><span class="toc-text">3.2.1.4. 非堆内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-内存调控"><span class="toc-text">3.2.2. 内存调控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-1-Storage内存"><span class="toc-text">3.2.2.1. Storage内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-1-1-申请"><span class="toc-text">3.2.2.1.1. 申请</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-1-2-释放"><span class="toc-text">3.2.2.1.2. 释放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-2-Excution内存"><span class="toc-text">3.2.2.2. Excution内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-2-1-申请"><span class="toc-text">3.2.2.2.1. 申请</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-2-2-释放"><span class="toc-text">3.2.2.2.2. 释放</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-BlockManager"><span class="toc-text">4. BlockManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-读数据"><span class="toc-text">4.1. 读数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-BlockManager集群"><span class="toc-text">4.2. BlockManager集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-状态管理"><span class="toc-text">4.3. 状态管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-读写控制"><span class="toc-text">5. 读写控制</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-2018-12-01-sparkCore-sorceCodeAnalysis-block" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">sparkCore源码解析之block</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.01.14</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>freeli</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="https://sustcoder.github.io//2019/01/14/2018-12-01-sparkCore-sorceCodeAnalysis-block/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/Block.png" alt="block"></p>
<h1 id="1-标记"><a href="#1-标记" class="headerlink" title="1. 标记"></a>1. <strong>标记</strong></h1><p>Apache Spark中，对Block的查询、存储管理，是通过唯一的Block ID来进行区分的。</p>
<p>同一个Spark Application，以及多个运行的Application之间，对应的Block都具有唯一的ID</p>
<h2 id="1-1-种类"><a href="#1-1-种类" class="headerlink" title="1.1. 种类"></a>1.1. <strong>种类</strong></h2><p>需要在worker和driver间共享数据时，就需要对这个数据进行唯一的标识，常用的需要传输的block信息有以下几类<br>RDDBlockId、ShuffleBlockId、ShuffleDataBlockId、ShuffleIndexBlockId、BroadcastBlockId、TaskResultBlockId、TempLocalBlockId、TempShuffleBlockId</p>
<h2 id="1-2-生成规则"><a href="#1-2-生成规则" class="headerlink" title="1.2. 生成规则"></a>1.2. <strong>生成规则</strong></h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">RDDBlockId</span> : <span class="string">"rdd_"</span> + rddId + <span class="string">"_"</span> + splitIndex</span><br><span class="line"><span class="type">ShuffleBlockId</span> : <span class="string">"shuffle_"</span> + shuffleId + <span class="string">"_"</span> + mapId + <span class="string">"_"</span> + reduceId</span><br><span class="line"><span class="type">ShuffleDataBlockId</span>:<span class="string">"shuffle_"</span> + shuffleId + <span class="string">"_"</span> + mapId + <span class="string">"_"</span> + reduceId + <span class="string">".data"</span></span><br><span class="line"><span class="type">ShuffleIndexBlockId</span>:<span class="string">"shuffle_"</span> + shuffleId + <span class="string">"_"</span> + mapId + <span class="string">"_"</span> + reduceId + <span class="string">".index"</span></span><br><span class="line"><span class="type">TaskResultBlockId</span>:<span class="string">"taskresult_"</span> + taskId</span><br><span class="line"><span class="type">StreamBlockId</span>:<span class="string">"input-"</span> + streamId + <span class="string">"-"</span> + uniqueId</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. <strong>存储</strong></h1><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E0A.tmp.jpg" alt="img"> </p>
<p>DiskStore是通过DiskBlockManager进行管理存储到磁盘上的Block数据文件的，在同一个节点上的多个Executor共享相同的磁盘文件路径，相同的Block数据文件也就会被同一个节点上的多个Executor所共享。而对应MemoryStore，因为每个Executor对应独立的JVM实例，从而具有独立的Storage/Execution内存管理，所以使用MemoryStore不能共享同一个Block数据，但是同一个节点上的多个Executor之间的MemoryStore之间拷贝数据，比跨网络传输要高效的多</p>
<h2 id="2-1-MemoryStore"><a href="#2-1-MemoryStore" class="headerlink" title="2.1. MemoryStore"></a>2.1. <strong>MemoryStore</strong></h2><p>数据在内存中存储的形式</p>
<ol>
<li>以序列化格式</li>
<li>以反序列化的形式<br> ​    2.1 Block数据记录能够完全放到内存中<br> ​    2.2 Block数据记录只能部分放到内存中：申请Unroll内存（预占内存）</li>
<li>以序列化二进制格式保存Block数据</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">MEMORY_ONLY</span></span><br><span class="line"><span class="type">MEMORY_ONLY_2</span></span><br><span class="line"><span class="type">MEMORY_ONLY_SER</span></span><br><span class="line"><span class="type">MEMORY_ONLY_SER_2</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK_2</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK_SER</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK_SER_2</span></span><br><span class="line"><span class="type">OFF_HEAP</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-DiskStore"><a href="#2-2-DiskStore" class="headerlink" title="2.2. DiskStore"></a>2.2. <strong>DiskStore</strong></h2><p>数据罗盘的几种形式：</p>
<ol>
<li>通过文件流写Block数据</li>
<li>将二进制Block数据写入文件</li>
<li><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">DISK_ONLY</span></span><br><span class="line"><span class="type">DISK_ONLY_2</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK_2</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK_SER</span></span><br><span class="line"><span class="type">MEMORY_AND_DISK_SER_2</span></span><br><span class="line"><span class="type">OFF_HEAP</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-2-1-DiskBlockManager"><a href="#2-2-1-DiskBlockManager" class="headerlink" title="2.2.1. DiskBlockManager"></a>2.2.1. <strong>DiskBlockManager</strong></h3><p>DiskStore即基于文件来存储Block. 基于Disk来存储,首先必须要解决一个问题就是磁盘文件的管理:磁盘目录结构的组成,目录的清理等,在Spark对磁盘文件的管理是通过 DiskBlockManager来进行管理的</p>
<p>DiskBlockManager管理了每个Block数据存储位置的信息，包括从Block ID到磁盘上文件的映射关系。DiskBlockManager主要有如下几个功能：</p>
<ol>
<li>负责创建一个本地节点上的指定磁盘目录，用来存储Block数据到指定文件中</li>
<li>如果Block数据想要落盘，需要通过调用getFile方法来分配一个唯一的文件路径</li>
<li>如果想要查询一个Block是否在磁盘上，通过调用containsBlock方法来查询</li>
<li>查询当前节点上管理的全部Block文件<br>通过调用createTempLocalBlock方法，生成一个唯一Block ID，并创建一个唯一的临时文件，用来存储中间结果数据</li>
<li>通过调用createTempShuffleBlock方法，生成一个唯一Block ID，并创建一个唯一的临时文件，用来存储Shuffle过程的中间结果数据<h2 id="2-3-offHeap"><a href="#2-3-offHeap" class="headerlink" title="2.3. offHeap"></a>2.3. <strong>offHeap</strong></h2></li>
</ol>
<p>堆外存储不支持序列化和副本</p>
<p>Spark中实现的OffHeap是基于Tachyon:分布式内存文件系统来实现的</p>
<h1 id="3-内存管理模型"><a href="#3-内存管理模型" class="headerlink" title="3. 内存管理模型"></a>3. <strong>内存管理模型</strong></h1><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E0C.tmp.jpg" alt="img"> </p>
<p>在Spark Application提交以后，最终会在Worker上启动独立的Executor JVM，Task就运行在Executor里面。在一个Executor JVM内部，内存管理模型就是管理excutor运行所需要的内存</p>
<p><a href="http://shiyanjun.cn/archives/1585.html" target="_blank" rel="noopener">http://shiyanjun.cn/archives/1585.html</a></p>
<h2 id="3-1-StaticMemoryManager"><a href="#3-1-StaticMemoryManager" class="headerlink" title="3.1. StaticMemoryManager"></a>3.1. <strong>StaticMemoryManager</strong></h2><p>1.5之前版本使用<br>缺点：</p>
<ol>
<li>没有一个合理的默认值能够适应不同计算场景下的Workload</li>
<li>内存调优困难，需要对Spark内部原理非常熟悉才能做好</li>
<li>对不需要Cache的Application的计算场景，只能使用很少一部分内存<h2 id="3-2-UnifiedMemoryManager"><a href="#3-2-UnifiedMemoryManager" class="headerlink" title="3.2. UnifiedMemoryManager"></a>3.2. <strong>UnifiedMemoryManager</strong></h2><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E0D.tmp.jpg" alt="img"> </li>
</ol>
<p>统一内存分配管理模型：</p>
<ol>
<li>可以动态的分配excution和storage的内存大小</li>
<li>不仅可以分配堆内内存，也可以分配堆外内存</li>
<li>堆外内存和分配比例都可以通过参数配置</li>
<li>内存的分配和回收是通过MemoryPool控制</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryManager</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">​    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">​    numCores: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">​    onHeapStorageMemory: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">​    onHeapExecutionMemory: <span class="type">Long</span></span>)</span>&#123;</span><br><span class="line">​	</span><br><span class="line"> <span class="comment">// storage堆内内存</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> onHeapStorageMemoryPool = 		<span class="keyword">new</span> <span class="type">StorageMemoryPool</span>(<span class="keyword">this</span>, 		<span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span>)</span><br><span class="line"> <span class="comment">// storage堆外内存</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> offHeapStorageMemoryPool = 		<span class="keyword">new</span> <span class="type">StorageMemoryPool</span>(<span class="keyword">this</span>, 		<span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span>)</span><br><span class="line"><span class="comment">// execution堆内内存</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> onHeapExecutionMemoryPool = 		<span class="keyword">new</span> <span class="type">ExecutionMemoryPool</span>(<span class="keyword">this</span>, 		<span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span>)</span><br><span class="line"><span class="comment">// excution堆外内存</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> offHeapExecutionMemoryPool = 		<span class="keyword">new</span> <span class="type">ExecutionMemoryPool</span>(<span class="keyword">this</span>, 		<span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认最大堆内存</span></span><br><span class="line"><span class="keyword">val</span> maxOffHeapMemory = conf.getSizeAsBytes(<span class="string">"spark.memory.offHeap.size"</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认storage和excution的内存大小各占50%</span></span><br><span class="line">offHeapStorageMemory =</span><br><span class="line">​    (maxOffHeapMemory * conf.getDouble(<span class="string">"spark.memory.storageFraction"</span>, <span class="number">0.5</span>)).toLong</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-内存划分"><a href="#3-2-1-内存划分" class="headerlink" title="3.2.1. 内存划分"></a>3.2.1. <strong>内存划分</strong></h3><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E1E.tmp.jpg" alt="img"> </p>
<p>在统一内存管理模型中，storage和excution内存大小可以动态调整，在一定程度上减少了OOM发生概率</p>
<p>默认内存划分：</p>
<p>预留内存reservedMemory=300M<br>管理内存maxHeapMemory = (systemMemory - reservedMemory) <em> 0.6<br>storageMemory=excutionMemory=maxHeapMemory</em>0.5</p>
<p>非堆内存默认值0，可通过spark.memory.offHeap.size参数调整，其中storage和excution的内存占比也均为50%</p>
<h4 id="3-2-1-1-Storage内存区"><a href="#3-2-1-1-Storage内存区" class="headerlink" title="3.2.1.1. Storage内存区"></a>3.2.1.1. <strong>Storage内存区</strong></h4><p>Storage内存，用来缓存Task数据、在Spark集群中传输（Propagation）内部数据</p>
<h4 id="3-2-1-2-Execution内存区"><a href="#3-2-1-2-Execution内存区" class="headerlink" title="3.2.1.2. Execution内存区"></a>3.2.1.2. <strong>Execution内存区</strong></h4><p>Execution内存，用于满足Shuffle、Join、Sort、Aggregation计算过程中对内存的需求</p>
<h4 id="3-2-1-3-预留内存"><a href="#3-2-1-3-预留内存" class="headerlink" title="3.2.1.3. 预留内存"></a>3.2.1.3. <strong>预留内存</strong></h4><h4 id="3-2-1-4-非堆内存"><a href="#3-2-1-4-非堆内存" class="headerlink" title="3.2.1.4. 非堆内存"></a>3.2.1.4. <strong>非堆内存</strong></h4><h3 id="3-2-2-内存调控"><a href="#3-2-2-内存调控" class="headerlink" title="3.2.2. 内存调控"></a>3.2.2. <strong>内存调控</strong></h3><p><img src="https://sustblog.oss-cn-beijing.aliyuncs.com/blog/2018/spark/sparkcore/wps6E2E.tmp.jpg" alt="img"> </p>
<h4 id="3-2-2-1-Storage内存"><a href="#3-2-2-1-Storage内存" class="headerlink" title="3.2.2.1. Storage内存"></a>3.2.2.1. <strong>Storage内存</strong></h4><h5 id="3-2-2-1-1-申请"><a href="#3-2-2-1-1-申请" class="headerlink" title="3.2.2.1.1. 申请"></a>3.2.2.1.1. <strong>申请</strong></h5><ol>
<li>判断申请内存类型：堆内还是堆外</li>
<li>如果申请内存大于剩余内存总量则申请失败</li>
<li>如果申请内存大小在storage内存范围内则直接分配</li>
<li>如果申请内存大于storage剩余内存则借用excution内存</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 为blockId申请numBytes字节大小的内存</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">acquireStorageMemory</span> </span>()synchronized &#123; </span><br><span class="line">  <span class="keyword">val</span> (executionPool, storagePool, maxMemory) = memoryMode <span class="keyword">match</span> &#123; </span><br><span class="line"><span class="comment">// 根据memoryMode值，返回对应的StorageMemoryPool与ExecutionMemoryPool</span></span><br><span class="line">​    <span class="keyword">case</span> <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span> =&gt;</span><br><span class="line">​    <span class="keyword">case</span> <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span> =&gt; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numBytes &gt; maxMemory) &#123;</span><br><span class="line"> <span class="comment">// 申请的内存大于剩余内存总理则申请失败</span></span><br><span class="line">​      <span class="string">s"memory limit (<span class="subst">$maxMemory</span> bytes)"</span>)</span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numBytes &gt; storagePool.memoryFree) &#123; </span><br><span class="line"><span class="comment">// 如果Storage内存块中没有足够可用内存给blockId使用，则计算当前Storage内存区缺少多少内存，然后从Execution内存区中借用</span></span><br><span class="line">​    <span class="keyword">val</span> memoryBorrowedFromExecution = <span class="type">Math</span>.min(executionPool.memoryFree, numBytes)</span><br><span class="line"><span class="comment">// Execution内存区减掉借用内存量</span></span><br><span class="line">executionPool.decrementPoolSize(memoryBorrowedFromExecution) </span><br><span class="line"><span class="comment">// Storage内存区增加借用内存量    storagePool.incrementPoolSize(memoryBorrowedFromExecution) </span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 如果Storage内存区可以为blockId分配内存，直接成功分配；否则，如果从Execution内存区中借用的内存能够满足blockId，则分配成功，不能满足则分配失败。</span></span><br><span class="line">  storagePool.acquireMemory(blockId, numBytes) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-1-2-释放"><a href="#3-2-2-1-2-释放" class="headerlink" title="3.2.2.1.2. 释放"></a>3.2.2.1.2. <strong>释放</strong></h5><p>释放Storage内存比较简单，只需要更新Storage内存计量变量即可</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseMemory</span></span>(size: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; _memoryUsed) &#123;</span><br><span class="line">​    <span class="comment">// 需要释放内存大于已使用内存，则直接清零</span></span><br><span class="line">​    _memoryUsed = <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">​	<span class="comment">// 从已使用内存中减去释放内存大小</span></span><br><span class="line">​    _memoryUsed -= size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-2-Excution内存"><a href="#3-2-2-2-Excution内存" class="headerlink" title="3.2.2.2. Excution内存"></a>3.2.2.2. <strong>Excution内存</strong></h4><p>excution内存的获取和释放都是线程安全的，而且分配给每个task的内存大小是均等的，每当有task运行完毕后，都会触发内存的回收操作。</p>
<h5 id="3-2-2-2-1-申请"><a href="#3-2-2-2-1-申请" class="headerlink" title="3.2.2.2.1. 申请"></a>3.2.2.2.1. <strong>申请</strong></h5><p>如果从storage申请内存大小比storage剩余内存大，则申请线程会阻塞，并对storage内存发起缩小操作。直到storage释放足够内存。</p>
<p>Execution内存区内存分配的基本原则：<br>如果有N个活跃（Active）的Task在运行，ExecutionMemoryPool需要保证每个Task在将中间结果数据Spill到磁盘之前，至少能够申请到当前Execution内存区对应的Pool中1/2N大小的内存量，至多是1/N大小的内存。</p>
<p>这里N是动态变化的，因为可能有新的Task被启动，也有可能Task运行完成释放资源，所以ExecutionMemoryPool会持续跟踪ExecutionMemoryPool内部Task集合memoryForTask的变化，并不断地重新计算分配给每个Task的这两个内存量的值：1/2N和1/N。</p>
<h5 id="3-2-2-2-2-释放"><a href="#3-2-2-2-2-释放" class="headerlink" title="3.2.2.2.2. 释放"></a>3.2.2.2.2. <strong>释放</strong></h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步的释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseMemory</span></span>(numBytes: <span class="type">Long</span>, taskAttemptId: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> curMem = memoryForTask.getOrElse(taskAttemptId, <span class="number">0</span>L)</span><br><span class="line"><span class="comment">// 计算释放内存大小</span></span><br><span class="line"> <span class="keyword">var</span> memoryToFree = <span class="keyword">if</span> (curMem &lt; numBytes) &#123; </span><br><span class="line">​	<span class="comment">// 没有足够内存需要释放，则释放掉当前task所有使用内存</span></span><br><span class="line">​    curMem</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">​    numBytes</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (memoryForTask.contains(taskAttemptId)) &#123; <span class="comment">// Task执行完成，从内部维护的memoryForTask中移除</span></span><br><span class="line">​    memoryForTask(taskAttemptId) -= memoryToFree</span><br><span class="line">​    <span class="keyword">if</span> (memoryForTask(taskAttemptId) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">​      memoryForTask.remove(taskAttemptId)</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 通知调用acquireMemory()方法申请内存的Task内存已经释放</span></span><br><span class="line">  lock.notifyAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-BlockManager"><a href="#4-BlockManager" class="headerlink" title="4. BlockManager"></a>4. <strong>BlockManager</strong></h1><p>BlockManagerMaster管理BlockManager.<br>BlockManager在每个Dirver和Executor上都有，用来管理Block数据，包括数据的获取和保存等</p>
<p>谈到Spark中的Block数据存储，我们很容易能够想到BlockManager，他负责管理在每个Dirver和Executor上的Block数据，可能是本地或者远程的。具体操作包括查询Block、将Block保存在指定的存储中，如内存、磁盘、堆外（Off-heap）。而BlockManager依赖的后端，对Block数据进行内存、磁盘存储访问，都是基于前面讲到的MemoryStore、DiskStore。<br>在Spark集群中，当提交一个Application执行时，该Application对应的Driver以及所有的Executor上，都存在一个BlockManager、BlockManagerMaster，而BlockManagerMaster是负责管理各个BlockManager之间通信，这个BlockManager管理集群</p>
<h2 id="4-1-读数据"><a href="#4-1-读数据" class="headerlink" title="4.1. 读数据"></a>4.1. <strong>读数据</strong></h2><p>每个Executor上都有一个BlockManager实例，负责管理用户提交的该Application计算过程中产生的Block。</p>
<p>很有可能当前Executor上存储在RDD对应Partition的经过处理后得到的Block数据，也有可能当前Executor上没有，但是其他Executor上已经处理过并缓存了Block数据，所以对应着本地获取、远程获取两种可能</p>
<h2 id="4-2-BlockManager集群"><a href="#4-2-BlockManager集群" class="headerlink" title="4.2. BlockManager集群"></a>4.2. <strong>BlockManager集群</strong></h2><p>关于一个Application运行过程中Block的管理，主要是基于该Application所关联的一个Driver和多个Executor构建了一个Block管理集群：Driver上的(BlockManagerMaster, BlockManagerMasterEndpoint)是集群的Master角色，所有Executor上的(BlockManagerMaster, RpcEndpointRef)作为集群的Slave角色。当Executor上的Task运行时，会查询对应的RDD的某个Partition对应的Block数据是否处理过，这个过程中会触发多个BlockManager之间的通信交互</p>
<h2 id="4-3-状态管理"><a href="#4-3-状态管理" class="headerlink" title="4.3. 状态管理"></a>4.3. <strong>状态管理</strong></h2><p>BlockManager在进行put操作后，通过blockInfoManager来控制当前put等操作是否完成以及是否成功。</p>
<p>对于BlockManager中的存储的每个Block,不一定是对应的数据都PUT成功了,不一定可以立即提供对外的读取,因为PUT是一个过程,有成功还是有失败的状态. ,拿ShuffleBlock来说,在shuffleMapTask需要Put一个Block到BlockManager中,在Put完成之前,该Block将处于Pending状态,等待Put完成了不代表Block就可以被读取, 因为Block还可能Put”fail”了.</p>
<p>因此BlockManager通过BlockInfo来维护每个Block状态,在BlockManager的代码中就是通过一个TimeStampedHashMap来维护BlockID和BlockInfo之间的map.</p>
<p>private val blockInfo = new TimeStampedHashMap[BlockId, BlockInfo]<br>注： 2.2中此处是通过线程安全的hashMap和一个计数器实现的 </p>
<h1 id="5-读写控制"><a href="#5-读写控制" class="headerlink" title="5. 读写控制"></a>5. <strong>读写控制</strong></h1><p>BlockInfoManager通过同步机制防止多个task处理同一个block数据块</p>
<p>用户提交一个Spark Application程序，如果程序对应的DAG图相对复杂，其中很多Task计算的结果Block数据都有可能被重复使用，这种情况下如何去控制某个Executor上的Task线程去读写Block数据呢？其实，BlockInfoManager就是用来控制Block数据读写操作，并且跟踪Task读写了哪些Block数据的映射关系，这样如果两个Task都想去处理同一个RDD的同一个Partition数据，如果没有锁来控制，很可能两个Task都会计算并写同一个Block数据，从而造成混乱</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockInfoManager</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> infos = </span><br><span class="line">		<span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">BlockId</span>, <span class="type">BlockInfo</span>]</span><br><span class="line">	<span class="comment">// 存放被锁定任务列表</span></span><br><span class="line">	<span class="keyword">val</span> writeLocksByTask =</span><br><span class="line">    	<span class="keyword">new</span> mutable.<span class="type">HashMap</span>[</span><br><span class="line">			<span class="type">TaskAttemptId</span>, mutable.<span class="type">Set</span>[<span class="type">BlockId</span>]]</span><br><span class="line">	 <span class="keyword">val</span> readLocksByTask =</span><br><span class="line">    	<span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">TaskAttemptId</span>, 		<span class="type">ConcurrentHashMultiset</span>[<span class="type">BlockId</span>]]</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lockForReading</span></span>(）&#123;</span><br><span class="line">		infos.get(blockId) <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">Some</span>(info) =&gt;</span><br><span class="line">				<span class="comment">// 没有写任务</span></span><br><span class="line">          		<span class="keyword">if</span> (info.writerTask == 					<span class="type">BlockInfo</span>.<span class="type">NO_WRITER</span>) &#123;</span><br><span class="line">					<span class="comment">// 读task数量加一</span></span><br><span class="line">            		info.readerCount += <span class="number">1</span></span><br><span class="line">					<span class="comment">//	放入读多锁定队列</span></span><br><span class="line"> 					readLocksByTask(</span><br><span class="line">					currentTaskAttemptId).</span><br><span class="line">					add(blockId)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lockForWriting</span></span>(）&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Some</span>(info) =&gt;</span><br><span class="line">          <span class="keyword">if</span> (info.writerTask == 				<span class="type">BlockInfo</span>.<span class="type">NO_WRITER</span> &amp;&amp; 				info.readerCount == <span class="number">0</span>) &#123;</span><br><span class="line">            info.writerTask = currentTaskAttemptId</span><br><span class="line"> 			writeLocksByTask.addBinding(</span><br><span class="line">			currentTaskAttemptId, blockId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持sustcoder</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/01/14/2018-12-01-sparkCore-sorceCodeAnalysis-shuffle/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/01/14/2018-12-01-sparkCore-sorceCodeAnalysis-Job/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>





   
      <div class="git"></div>
   
</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/blog/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'https://sustcoder.github.io/2019/01/14/2018-12-01-sparkCore-sorceCodeAnalysis-block/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
